Prueba 1:
// 1. DEFINICIÃ“N: Creamos un "Saco de Boxeo" para pruebas
Actor.define('DummyTarget', {
    vars: { hp: 100, name: 'Saco de Boxeo' }
}, {
    // LÃ³gica simple: Si recibe 'golpe', baja vida
    test_hit: (me, data) => {
        const newHp = me.vars.hp - data.dmg;
        me.setVar('hp', newHp);
        console.log(`ğŸ¥Š [TEST] Dummy recibiÃ³ ${data.dmg} daÃ±o. Vida: ${newHp}`);
    }
});

// 2. EJECUCIÃ“N DEL TEST (Se corre una vez al iniciar)
// Usamos setTimeout para dar tiempo a que el sistema arranque
setTimeout(() => {
    console.log("ğŸ§ª --- INICIANDO TEST AUTOMÃTICO ---");

    // A. SETUP: Crear el actor
    const dummy = Actor.create('DummyTarget', { hp: 100 });
    
    // B. ASSERT PREVIO: Verificar estado inicial
    if (dummy.vars.hp !== 100) console.error("âŒ Fallo Setup");
	
    console.log("Buscando actores: ", Actor.getActorsByGrupo("DummyTarget"));
    // C. ACT: Simular la acciÃ³n (Sin necesidad de clientes reales)
    // Forzamos el evento 'test_hit'
    dummy.receive('test_hit', { dmg: 40 });

    // D. ASSERT POSTERIOR: Verificar resultado
    if (dummy.vars.hp === 60) {
        console.log("âœ… PRUEBA PASADA: El daÃ±o se calculÃ³ correctamente.");
    } else {
        console.error(`âŒ PRUEBA FALLIDA: Esperaba 60, tengo ${dummy.vars.hp}`);
    }

    // E. CLEANUP: Limpiar
    dummy.selfDestruct();
    console.log("ğŸ§ª --- TEST FINALIZADO destruccion del actor---");
    console.log("Buscando actores: ", Actor.getActorsByGrupo("DummyTarget"));
}, 2000);
Console:
ğŸ§ª --- INICIANDO TEST AUTOMÃTICO ---
Buscando actores:  [
  Entity {
    id: 1,
    grupo: 'DummyTarget',
    hub: SignalHub { channels: [Map], globalId: 1 },
    vars: { hp: 100, name: 'Saco de Boxeo' },
    channelsIn: [ 'DummyTarget', 'global' ],
    channelsOut: [ 'DummyTarget', 'global' ],
    writingAllowed: false,
    destructedAutomatic: false
  }
]
ğŸ¥Š [TEST] Dummy recibiÃ³ 40 daÃ±o. Vida: 60
âœ… PRUEBA PASADA: El daÃ±o se calculÃ³ correctamente.
ğŸ§ª --- TEST FINALIZADO destruccion del actor---
Buscando actores:  []

Prueba 2: solicitud y retorno entre actores (funcion receive, me, sender)
// =============================================================
// 1. DEFINICIÃ“N DE ACTORES
// =============================================================

// --- EL COMANDANTE (Emisor de Ã³rdenes) ---
Actor.define('Comandante', { 
    vars: { nombre: 'General Shepard', rango: 5 } 
}, {
    // ReacciÃ³n cuando el soldado confirma la orden
    reporte_soldado: (me, data, sender) => {
        console.log(`ğŸ–ï¸ [COMANDANTE] Recibido reporte de ${sender.vars.nombre}: "${data.msg}"`);
        console.log(`ğŸ–ï¸ [COMANDANTE] Estado de la misiÃ³n: VERDE.`);
    }
});

// --- EL SOLDADO (El que sufre y pide ayuda) ---
Actor.define('Soldado', { 
    vars: { hp: 10, nombre: 'Pvt. Ryan', estado: 'Herido' } 
}, {
    // 1. Recibe orden del General
    orden_ataque: (me, data, sender) => {
        console.log(`ğŸª– [SOLDADO] Orden recibida de ${sender.vars.nombre}: Atacar.`);
        
        if (me.vars.hp < 50) {
            console.log(`ğŸª– [SOLDADO] Â¡Estoy muy herido (${me.vars.hp} HP)! No puedo atacar.`);
            console.log(`ğŸª– [SOLDADO] Buscando mÃ©dico cercano...`);
            
            // BUSCAR UN ACTOR MÃ‰DICO
            const medicos = Actor.getActorsByGrupo('Medico');
            if (medicos.length > 0) {
                const doc = medicos[0]; // Agarramos el primero
                console.log(`ğŸ“¡ [SOLDADO -> MÃ‰DICO] Solicitando curaciÃ³n a ${doc.vars.nombre}...`);
                
                // COMUNICACIÃ“N: Soldado -> MÃ©dico
                // Pasamos 'me' como tercer argumento para que el mÃ©dico sepa quiÃ©n pide ayuda
                doc.receive('solicitud_curacion', { prioridad: 'ALTA' }, me);
            } else {
                console.log(`ğŸ’€ [SOLDADO] No hay mÃ©dicos. Muriendo...`);
            }
        }
    },

    // 3. Recibe la curaciÃ³n del MÃ©dico
    recibir_botiquin: (me, data, sender) => {
        console.log(`â¤ï¸ [SOLDADO] Recibiendo ${data.amount} HP de ${sender.vars.nombre}.`);
        
        const nuevaVida = me.vars.hp + data.amount;
        me.setVar('hp', nuevaVida);
        me.setVar('estado', 'Listo');
        
        console.log(`ğŸª– [SOLDADO] Vida actual: ${me.vars.hp}. Estado: ${me.vars.estado}.`);

        // 4. Comunicar de vuelta al Comandante (suponiendo que sabemos quiÃ©n es o lo buscamos)
        const jefes = Actor.getActorsByGrupo('Comandante');
        if (jefes.length > 0) {
            console.log(`ğŸ“¡ [SOLDADO -> COMANDANTE] Confirmando disponibilidad.`);
            jefes[0].receive('reporte_soldado', { msg: 'Recuperado y avanzando.' }, me);
        }
    }
});

// --- EL MÃ‰DICO (El soporte) ---
Actor.define('Medico', { 
    vars: { nombre: 'Doc', botiquines: 5 } 
}, {
    // 2. Recibe solicitud del Soldado
    solicitud_curacion: (me, data, sender) => {
        console.log(`ğŸš‘ [MÃ‰DICO] Solicitud de ${sender.vars.nombre} recibida. Prioridad: ${data.prioridad}.`);
        
        if (me.vars.botiquines > 0) {
            me.setVar('botiquines', me.vars.botiquines - 1);
            console.log(`ğŸš‘ [MÃ‰DICO] Aplicando curaciÃ³n. Botiquines restantes: ${me.vars.botiquines}.`);
            
            // COMUNICACIÃ“N: MÃ©dico -> Soldado (Respuesta)
            sender.receive('recibir_botiquin', { amount: 90 }, me);
        } else {
            console.log(`ğŸš‘ [MÃ‰DICO] Â¡No me quedan botiquines!`);
        }
    }
});


// =============================================================
// 2. ESCENARIO DE PRUEBA (EjecuciÃ³n)
// =============================================================

setTimeout(() => {
    console.log("\nğŸ¬ --- INICIO DE LA SIMULACIÃ“N DE ACTORES ---\n");

    // A. CREAMOS LOS ACTORES
    const general = Actor.create('Comandante', {});
    const ryan = Actor.create('Soldado', { hp: 10, nombre: 'Ryan' });
    const doc = Actor.create('Medico', { nombre: 'House' });

    console.log(`âœ… Actores en escena:`);
    console.log(`   > ${general.vars.nombre} (ID: ${general.id})`);
    console.log(`   > ${ryan.vars.nombre} (ID: ${ryan.id}) [HP: ${ryan.vars.hp}]`);
    console.log(`   > ${doc.vars.nombre} (ID: ${doc.id})\n`);

    // B. DETONAMOS LA CADENA DE EVENTOS
    console.log("âš¡ [ACCIÃ“N] El General da la orden...");
    
    // El general envÃ­a el mensaje al soldado
    // 'general' es el sender (remitente)
    ryan.receive('orden_ataque', {}, general);

}, 1000);
Console:
ğŸ¬ --- INICIO DE LA SIMULACIÃ“N DE ACTORES ---

âœ… Actores en escena:
   > General Shepard (ID: 1)
   > Ryan (ID: 2) [HP: 10]
   > House (ID: 3)

âš¡ [ACCIÃ“N] El General da la orden...
ğŸª– [SOLDADO] Orden recibida de General Shepard: Atacar.
ğŸª– [SOLDADO] Â¡Estoy muy herido (10 HP)! No puedo atacar.
ğŸª– [SOLDADO] Buscando mÃ©dico cercano...
ğŸ“¡ [SOLDADO -> MÃ‰DICO] Solicitando curaciÃ³n a House...
ğŸš‘ [MÃ‰DICO] Solicitud de Ryan recibida. Prioridad: ALTA.
ğŸš‘ [MÃ‰DICO] Aplicando curaciÃ³n. Botiquines restantes: 4.
â¤ï¸ [SOLDADO] Recibiendo 90 HP de House.
ğŸª– [SOLDADO] Vida actual: 100. Estado: Listo.
ğŸ“¡ [SOLDADO -> COMANDANTE] Confirmando disponibilidad.
ğŸ–ï¸ [COMANDANTE] Recibido reporte de Ryan: "Recuperado y avanzando."
ğŸ–ï¸ [COMANDANTE] Estado de la misiÃ³n: VERDE


Prueba 3: comunicacion entre actores.
// =============================================================
// DEFINICIÃ“N: DRON ESPÃA (La entidad compleja)
// =============================================================
Actor.define('DronEspia', {
    vars: { id_interno: 'X-99', estado: 'Inactivo' },
    // Nace escuchando solo su canal de control directo
    onCanal: ['CONTROL_REMOTO'] 
}, {
    
    // 1. INICIALIZACIÃ“N (setVar, emitClient)
    activar_protocolo: (me, data) => {
        console.log(`ğŸ¤– [DRON] Recibiendo orden de activaciÃ³n...`);
        
        // setVar: Guardamos datos crÃ­ticos recibidos dinÃ¡micamente
        me.setVar('estado', 'Escaneando');
        me.setVar('datos_sensibles', data.secretCode); 
        console.log(`ğŸ’¾ [VAR] Datos sensibles guardados en memoria: ${me.vars.datos_sensibles}`);

        // emitClient: Avisamos solo al dueÃ±o (UI) que el dron despertÃ³
        // (Esto pintarÃ­a algo en la pantalla del jugador)
        me.emitClient('hud_update', { status: 'ONLINE', battery: 100 });
        console.log(`ğŸ–¥ï¸ [CLIENT] HUD actualizado.`);

        // Siguiente paso automÃ¡tico
        me.receive('conectar_y_transmitir', {});
    },

    // 2. COMUNICACIÃ“N DINÃMICA (pushChannel, emit, deleteChannel)
    conectar_y_transmitir: (me, data) => {
        const CANAL_DESTINO = 'SERVIDOR_SECRETO';
        
        // pushChannel: Nos conectamos dinÃ¡micamente a un canal seguro
        // 'out' significa que queremos HABLAR en ese canal, no escuchar
        console.log(`ğŸ“¡ [CHANNEL] Conectando a frecuencia encriptada: ${CANAL_DESTINO}`);
        me.pushChannel('out', CANAL_DESTINO);

        // emit: Enviamos los datos a ese canal especÃ­fico (sino se especifica envia a todos los canales de su lista que en este caso es el agregado SERVIDOR_SECRETO y por defecto global)
        console.log(`ğŸ“¤ [EMIT] Transmitiendo paquete de datos...`);
        me.emit('PAQUETE_ROBADO', { 
            codigo: me.vars.datos_sensibles, 
            origen: me.vars.id_interno 
        }, CANAL_DESTINO);

        // deleteChannel: Nos desconectamos inmediatamente para no ser rastreados
        me.deleteChannel('out', CANAL_DESTINO);
        console.log(`âœ‚ï¸ [CHANNEL] DesconexiÃ³n tÃ¡ctica realizada.`);

        // Siguiente paso
        me.receive('limpieza_datos', {});
    },

    // 3. LIMPIEZA DE MEMORIA (deleteVar)
    limpieza_datos: (me, data) => {
        console.log(`ğŸ§¹ [CLEANUP] Iniciando borrado de memoria RAM...`);
        
        // deleteVar: Eliminamos la variable para liberar memoria del servidor
        // y asegurar que si alguien inspecciona la entidad, no encuentre el cÃ³digo.
        if (me.vars.datos_sensibles) {
            me.deleteVar('datos_sensibles');
            console.log(`ğŸ—‘ï¸ [VAR] Variable 'datos_sensibles' eliminada.`);
        }
        
        console.log(`ğŸ” [CHECK] Vars actuales:`, JSON.stringify(me.vars));
        
        // Siguiente paso
        me.receive('protocolo_abandono', {});
    },

    // 4. AUTODESTRUCCIÃ“N INTELIGENTE (setDestructedAutomatic)
    protocolo_abandono: (me, data) => {
        console.log(`âš ï¸ [SYSTEM] Iniciando protocolo de abandono.`);
        
        // setDestructedAutomatic: Configuramos al actor para que muera si se queda "sordo"
        // (Si su lista de canales de entrada 'channelsIn' llega a 0 mas no de salida, solo de entrada. si se cumple se autoelimina)
        me.setDestructedAutomatic(true);
        console.log(`âš™ï¸ [AUTO-DESTRUCT] Armado. Si se pierde la seÃ±al, la entidad se borrarÃ¡.`);

        // deleteChannel ('in'): Dejamos de escuchar el canal de control
        // Al hacer esto, como 'channelsIn' queda vacÃ­o y el flag anterior es true,
        // la entidad deberÃ­a autodestruirse sola.
        console.log(`âœ‚ï¸ [CHANNEL] Cortando cable de control (CONTROL_REMOTO)...`);
        me.deleteChannel('in', 'CONTROL_REMOTO');
        me.deleteChannel('in', 'DronEspia') // por defecto todos los actores oyen y hablan con los de su propia especie.
        me.deleteChannel('in', 'global'); // por defecto todos los actores oyen y hablan con el canal global.
        
        // Nota: No necesitamos llamar a selfDestruct() aquÃ­ explÃ­citamente, 
        // el motor lo harÃ¡ por nosotros al detectar que no hay canales.
    }
});

// DEFINICIÃ“N: SERVIDOR SECRETO (Para verificar que el emit llegÃ³)
Actor.define('BaseSecreta', { vars: {} }, { // No escucha nada por defecto
    // Se define la lÃ³gica, pero la suscripciÃ³n serÃ¡ dinÃ¡mica o manual en este test
    PAQUETE_ROBADO: (me, data) => {
        console.log(`ğŸ¢ [BASE SECRETA] Â¡Paquete recibido! CÃ³digo: ${data.codigo}`);
    }
});


// =============================================================
// EJECUCIÃ“N DE LA PRUEBA
// =============================================================

setTimeout(() => {
    console.log("\nğŸ§ª --- INICIO PRUEBA DE GESTIÃ“N DE RECURSOS ---\n");

    // 1. Crear el Dron
    const dron = Actor.create('DronEspia', {});
    
    // 2. Crear la Base y suscribirla manualmente al canal secreto
    const base = Actor.create('BaseSecreta', {});
    base.pushChannel('in', 'SERVIDOR_SECRETO'); 

    // 3. DETONAR LA SECUENCIA
    // receive: Forzamos el primer evento desde "fuera"
    console.log("âš¡ [TEST] Inyectando evento inicial...");
    dron.receive('activar_protocolo', { secretCode: 'LAUNCH_NUKE_123' });

    // 4. VERIFICACIÃ“N FINAL (Un poco despuÃ©s para ver si muriÃ³)
    setTimeout(() => {
        const dronesVivos = Actor.getActorsByGrupo('DronEspia');
        console.log("\nğŸ” --- VERIFICACIÃ“N FINAL ---");
        if (dronesVivos.length === 0) {
            console.log("âœ… Ã‰XITO: El dron se autodestruyÃ³ correctamente tras perder la seÃ±al.");
        } else {
            console.log("âŒ ERROR: El dron sigue vivo.");
            console.log(dronesVivos);
        }
    }, 500);

}, 1000);
Console:
ğŸ§ª --- INICIO PRUEBA DE GESTIÃ“N DE RECURSOS ---

âš¡ [TEST] Inyectando evento inicial...
ğŸ¤– [DRON] Recibiendo orden de activaciÃ³n...
ğŸ’¾ [VAR] Datos sensibles guardados en memoria: LAUNCH_NUKE_123
ğŸ–¥ï¸ [CLIENT] HUD actualizado.
ğŸ“¡ [CHANNEL] Conectando a frecuencia encriptada: SERVIDOR_SECRETO
ğŸ“¤ [EMIT] Transmitiendo paquete de datos...
ğŸ¢ [BASE SECRETA] Â¡Paquete recibido! CÃ³digo: LAUNCH_NUKE_123
âœ‚ï¸ [CHANNEL] DesconexiÃ³n tÃ¡ctica realizada.
ğŸ§¹ [CLEANUP] Iniciando borrado de memoria RAM...
ğŸ—‘ï¸ [VAR] Variable 'datos_sensibles' eliminada.
ğŸ” [CHECK] Vars actuales: {"id_interno":"X-99","estado":"Escaneando"}
âš ï¸ [SYSTEM] Iniciando protocolo de abandono.
âš™ï¸ [AUTO-DESTRUCT] Armado. Si se pierde la seÃ±al, la entidad se borrarÃ¡.
âœ‚ï¸ [CHANNEL] Cortando cable de control (CONTROL_REMOTO)...

ğŸ” --- VERIFICACIÃ“N FINAL ---
âœ… Ã‰XITO: El dron se autodestruyÃ³ correctamente tras perder la seÃ±al.

Prueba Final: Recepcion de datos del cliente.
Server logic atributo:
// =============================================================
// DEFINICIÃ“N DEL ACTOR DE PRUEBA
// =============================================================
Actor.define('Tester', {
    vars: { x: 0, y: 0, status: 'Idle', energy: 100 }
}, {
    // 1. Recibir Movimiento
    sync_position: (me, data) => {
        const prevX = me.vars.x;
        me.setVar('x', data.x);
        me.setVar('y', data.y);
        
        console.log(`ğŸ“ [SERVER:ACTOR] ${data.id} movido. X: ${prevX} -> ${data.x}`);
    },

    // 2. Recibir Habilidad (Prueba de LÃ³gica)
    execute_test_skill: (me, data) => {
        console.log(`âš¡ [SERVER:ACTOR] Ejecutando Skill: ${data.name}`);
        
        if (me.vars.energy >= 10) {
            me.setVar('energy', me.vars.energy - 10);
            me.setVar('status', 'Casting');
            
            // Confirmar al cliente que funcionÃ³
            me.emitClient('skill_confirmed', { 
                remainingEnergy: me.vars.energy,
                msg: 'Habilidad procesada correctamente'
            });
        } else {
            console.log(`âš ï¸ [SERVER:ACTOR] EnergÃ­a insuficiente.`);
        }
    }
});

// =============================================================
// RUTEO DE INPUTS
// =============================================================
function onInput(packet, state) {
    // Buscamos al actor por el ID del socket
    const actors = Actor.getActorsByGrupo('Tester');
    let me = actors.find(a => a.vars.id === packet.id);

    switch (packet.type) {
        
        // PASO 1: CONEXIÃ“N
        case 'join_test':
            if (!me) {
                console.log(`ğŸ”Œ [SERVER:NET] Solicitud de Join recibida: ${packet.id}`);
                me = Actor.create('Tester', {
                    id: packet.id,
                    x: 0,
                    y: 0
                });
                me.emitClient('test_start', { msg: 'SesiÃ³n de prueba iniciada' });
            }
            break;

        // PASO 2: MOVIMIENTO AUTOMÃTICO
        case 'auto_move':
            if (me) {
                me.receive('sync_position', packet);
            }
            break;

        // PASO 3: ACCIÃ“N AUTOMÃTICA
        case 'auto_skill':
            if (me) {
                me.receive('execute_test_skill', packet);
            }
            break;

        // PASO 4: DESCONEXIÃ“N
        case 'player_leave':
            if (me) {
                console.log(`ğŸ [SERVER:NET] Test finalizado para ${packet.id}. Limpiando.`);
                me.selfDestruct();
            }
            break;
    }
    console.log(state);
}
Client atributo:

    
    console.log("ğŸ¤– [CLIENT] Iniciando secuencia de prueba automatizada...");

    const MY_ID = Client.myId || 'AutoBot_' + Math.floor(Math.random()*100);

    // --- SECUENCIA DE EVENTOS ---

    // T+0ms: UNIRSE
    setTimeout(() => {
        console.log("ğŸ“¤ [CLIENT] Enviando: join_test");
        Client.emit('join_test', { id: MY_ID });
    }, 100);

    // T+1000ms: MOVERSE (Simular paso 1)
    setTimeout(() => {
        console.log("ğŸ“¤ [CLIENT] Enviando: auto_move (X=10)");
        Client.emit('auto_move', { x: 10, y: 0 });
    }, 1000);

    // T+2000ms: MOVERSE (Simular paso 2)
    setTimeout(() => {
        console.log("ğŸ“¤ [CLIENT] Enviando: auto_move (X=25)");
        Client.emit('auto_move', { x: 25, y: 5 });
    }, 2000);

    // T+3000ms: USAR HABILIDAD
    setTimeout(() => {
        console.log("ğŸ“¤ [CLIENT] Enviando: auto_skill");
        Client.emit('auto_skill', { name: 'HyperBeam' });
    }, 3000);

    // T+4000ms: FINALIZAR (Simulamos desconexiÃ³n lÃ³gica)
    setTimeout(() => {
        console.log("âœ… [CLIENT] Secuencia finalizada.");
    }, 4000);

    // --- ESCUCHAR RESPUESTAS DEL SERVIDOR (VerificaciÃ³n) ---
    
    Client.on('test_start', (data) => {
        console.log(`ğŸ“¥ [CLIENT] Recibido 'test_start': ${data.msg}`);
    });

    Client.on('skill_confirmed', (data) => {
        console.log(`ğŸ“¥ [CLIENT] Recibido 'skill_confirmed'. EnergÃ­a restante en server: ${data.remainingEnergy}`);
    });


window.onInputLoop = () => {};
Console Server:
ğŸ”Œ [SERVER:NET] Solicitud de Join recibida: aldo
{
  masterMap: Map(0) {},
  isPaused: false,
  Tester: [ { x: 0, y: 0, status: 'Idle', energy: 100, id: 'aldo' } ]
}
ğŸ“ [SERVER:ACTOR] aldo movido. X: 0 -> 10
{
  masterMap: Map(0) {},
  isPaused: false,
  Tester: [ { x: 10, y: 0, status: 'Idle', energy: 100, id: 'aldo' } ]
}
ğŸ“ [SERVER:ACTOR] aldo movido. X: 10 -> 25
{
  masterMap: Map(0) {},
  isPaused: false,
  Tester: [ { x: 25, y: 5, status: 'Idle', energy: 100, id: 'aldo' } ]
}
âš¡ [SERVER:ACTOR] Ejecutando Skill: HyperBeam
{
  masterMap: Map(0) {},
  isPaused: false,
  Tester: [ { x: 25, y: 5, status: 'Casting', energy: 90, id: 'aldo' } ]
}

Console Client:
ğŸ¤– [CLIENT] Iniciando secuencia de prueba automatizada...
play?room=Sala%20Nueva:1034 ğŸ› ï¸ CÃ³digo inyectado.
VM252:11 ğŸ“¤ [CLIENT] Enviando: join_test
VM252:41 ğŸ“¥ [CLIENT] Recibido 'test_start': SesiÃ³n de prueba iniciada
VM252:17 ğŸ“¤ [CLIENT] Enviando: auto_move (X=10)
VM252:23 ğŸ“¤ [CLIENT] Enviando: auto_move (X=25)
VM252:29 ğŸ“¤ [CLIENT] Enviando: auto_skill
VM252:45 ğŸ“¥ [CLIENT] Recibido 'skill_confirmed'. EnergÃ­a restante en server: 90
VM252:35 âœ… [CLIENT] Secuencia finalizada.