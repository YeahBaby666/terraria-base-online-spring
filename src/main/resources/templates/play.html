<!DOCTYPE html>
<html lang="es" xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <title>Jugar - Engine IO</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
    <style>
        body {
            margin: 0;
            background: #111;
            overflow: hidden;
            user-select: none;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        #ui-layer {
            position: absolute;
            inset: 0;
            z-index: 10;
            pointer-events: none;
        }

        #ui-layer * {
            pointer-events: auto;
        }

        #loader {
            position: absolute;
            inset: 0;
            background: #0f172a;
            color: white;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top: 4px solid #4ade80;
            width: 40px;
            height: 40px;
            animation: spin 0.8s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body th:data-room-id="${roomId}" th:data-user-name="${currentUsername}" th:data-api-base="${ApiBaseUrl}">

    <div id="loader">
        <div class="spinner"></div>
        <div id="status">Conectando...</div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer" th:utext="${clientStructureHtml}"></div>

    <script>


        class CollisionMap {
            constructor(tileSize = 80) {
                this.data = new Map();
                this.tileSize = tileSize;
            }

            setRect(x, y, w, h, solid = true) {
                const rect = { l: x, r: x + w, t: y, b: y + h };

                const startX = Math.floor(rect.l / this.tileSize);
                const startY = Math.floor(rect.t / this.tileSize);
                const endX = Math.floor(rect.r / this.tileSize);
                const endY = Math.floor(rect.b / this.tileSize);

                // LOG DE DEBUG PARA VER QU√â PASA
                if (!solid) {
                    console.log(`üîç Intentando borrar en Grid: X[${startX}-${endX}] Y[${startY}-${endY}]`);
                }
                console.log(`üß± ${solid ? 'Creando' : 'Borrando'} rect: L:${rect.l}, T:${rect.t}, R:${rect.r}, B:${rect.b}`);

                for (let gy = startY; gy <= endY; gy++) {
                    for (let gx = startX; gx <= endX; gx++) {
                        const key = `${gx},${gy}`;

                        if (solid) {
                            // --- CREAR ---
                            if (!this.data.has(key)) this.data.set(key, []);
                            this.data.get(key).push(rect);
                        }
                        else {
                            // --- BORRAR ---
                            // AQU√ç EST√Å EL DIAGN√ìSTICO:
                            const existe = this.data.has(key);

                            if (existe) {
                                const list = this.data.get(key);
                                const lenAntes = list.length;

                                // Filtro Tolerante (0.1px de margen)
                                const newList = list.filter(r => {
                                    const matchL = Math.abs(r.l - rect.l) < 0.1;
                                    const matchT = Math.abs(r.t - rect.t) < 0.1;
                                    const matchR = Math.abs(r.r - rect.r) < 0.1;
                                    const matchB = Math.abs(r.b - rect.b) < 0.1;

                                    // Si TODO coincide, es el bloque que queremos borrar (retornamos false para sacarlo)
                                    const esElBloque = matchL && matchT && matchR && matchB;
                                    return !esElBloque;
                                });

                                // Guardamos cambios
                                if (newList.length === 0) this.data.delete(key);
                                else this.data.set(key, newList);

                                console.log(`   üìâ Elementos antes: ${lenAntes}, despu√©s: ${newList.length}`);
                            }
                        }
                    }
                }
            }

            checkPixel(x, y) {
                const gx = Math.floor(x / this.tileSize);
                const gy = Math.floor(y / this.tileSize);
                const key = `${gx},${gy}`;
                const cellObjects = this.data.get(key);

                if (!cellObjects) return false;

                for (const r of cellObjects) {
                    if (x >= r.l && x < r.r && y >= r.t && y < r.b) return true;
                }
                return false;
            }
        }




        class PhysicsCore {
            constructor(map) {
                this.map = map;
                this.gravity = 1200;
                this.friction = 0.8;
            }

            // AHORA RECIBE 'currentGravity'
            update(ent, dt, currentGravity) {
                if (ent.static) return;

                // Usamos la gravedad pasada por par√°metro, o la global si es undefined
                const g = (currentGravity !== undefined) ? currentGravity : this.gravity;

                // 1. Gravedad din√°mica
                ent.vy = (ent.vy || 0) + g * dt;

                // Terminal velocity (limitamos para que no atraviese el suelo por velocidad extrema)
                if (ent.vy > 1000) ent.vy = 1000;
                if (ent.vy < -1000) ent.vy = -1000;

                // 2. Fricci√≥n
                if (ent.onGround) ent.vx *= this.friction;
                else ent.vx *= 0.95;

                if (Math.abs(ent.vx) < 1) ent.vx = 0;

                // 3. MOVIMIENTO STEPPING
                this.stepAxis(ent, ent.vx * dt, 'x');
                this.stepAxis(ent, ent.vy * dt, 'y');
            }

            stepAxis(ent, amount, axis) {
                if (amount === 0) return;

                const dir = Math.sign(amount);
                const totalDist = Math.abs(amount); // Distancia total absoluta
                let movedDist = 0; // Cu√°nto nos hemos movido realmente

                // 1. PASOS ENTEROS (1px por loop)
                // Usamos un while para consumir la distancia paso a paso
                while (movedDist + 1 <= totalDist) {
                    if (!this.tryMove(ent, axis, dir)) {
                        // Si chocamos, velocidad a 0 y terminamos
                        if (axis === 'x') ent.vx = 0; else ent.vy = 0;
                        return;
                    }
                    movedDist += 1;
                }

                // 2. PASO DECIMAL FINAL (El resto: ej 0.8)
                const remainder = totalDist - movedDist;
                if (remainder > 0) {
                    // Importante: Usamos una tolerancia m√≠nima para no mover cosas microsc√≥picas
                    if (remainder > 0.001) {
                        if (!this.tryMove(ent, axis, dir * remainder)) {
                            if (axis === 'x') ent.vx = 0; else ent.vy = 0;
                        }
                    }
                }
            }

            // Retorna TRUE si se movi√≥ libremente, FALSE si choc√≥ (Boolean check)
            tryMove(ent, axis, val) {
                const testX = axis === 'x' ? ent.x + val : ent.x;
                const testY = axis === 'y' ? ent.y + val : ent.y;

                // Hitbox (Asumimos tama√±o est√°ndar o el que tenga la entidad)
                const w = ent.width || 20;
                const h = ent.height || 38;

                // Margen para no pegarse (anti-friction ghosting)
                const eps = 0.01;
                // ‚òÖ NUEVO: Calculamos el punto medio (Cintura)
                const centerY = testY + h / 2;
                const centerX = testX + w / 2;

                const hit =
                    // 1. Esquinas Superiores (Cabeza)
                    this.map.checkPixel(testX + eps, testY + eps) ||
                    this.map.checkPixel(testX + w - eps, testY + eps) ||

                    // 2. Esquinas Inferiores (Pies)
                    this.map.checkPixel(testX + eps, testY + h - eps) ||
                    this.map.checkPixel(testX + w - eps, testY + h - eps) ||

                    // 3. ‚òÖ Puntos Medios Laterales (Cintura) - EVITA EL TRASPASO LATERAL
                    this.map.checkPixel(testX + eps, centerY) ||               // Izquierda Centro
                    this.map.checkPixel(testX + w - eps, centerY) ||           // Derecha Centro

                    // 4. ‚òÖ Puntos Medios Verticales (Opcional, robustez extra)
                    this.map.checkPixel(centerX, testY + eps) ||               // Arriba Centro
                    this.map.checkPixel(centerX, testY + h - eps);             // Abajo Centro
                if (hit) {
                    // L√≥gica de choque
                    if (axis === 'y') {
                        if (val > 0) ent.onGround = true; // Suelo
                        else ent.onGround = false;        // Techo
                    }
                    return false; // STOP LOOP
                }

                // Camino libre -> Aplicar
                ent.x = testX;
                ent.y = testY;
                if (axis === 'y') ent.onGround = false;
                return true; // CONTINUE LOOP
            }
        }

        class PhysicsAPI {
            constructor(engine) {
                this.engine = engine;
                this.map = new CollisionMap();
                this.core = new PhysicsCore(this.map);
                this.entities = []; // Lista de { ent, group }
                this.running = false;
                this.pausedGroups = new Set();
                this.groupGravity = new Map();
                
            }

            // --- M√âTODOS DE CONFIGURACI√ìN ---

            // Client.setFisicaMap(bloques, autoStart)
            initMap(blocks = [], autoStart = true) {
                this.map.data.clear();
                // Carga inicial de bloques si se pasan
                blocks.forEach(b => this.setBlock(b.x, b.y, b.w, b.h, true));
                if (autoStart) this.start();
            }

            // Client.setBlock(x, y, w, h)
            setBlock(x, y, w, h, solid = true) {
                this.map.setRect(x, y, w, h, solid);
                // Opcional: Debug visual inmediato
                // Client.drawRect(x, y, w, h, 'rgba(255,0,0,0.5)'); 
            }

            // Client.setEntidades([jugador, zombies], grupo)
            addEntities(list, group = 'default') {
                if (!Array.isArray(list)) list = [list];
                list.forEach(ent => {
                    // Inyectamos propiedades f√≠sicas si no las tienen
                    if (ent.vx === undefined) ent.vx = 0;
                    if (ent.vy === undefined) ent.vy = 0;
                    this.entities.push({ ref: ent, group: group });
                });
            }

            // Client.setEntidad(ent, x, y)
            setTransform(ent, x, y) {
                ent.x = x;
                ent.y = y;
                ent.vx = 0; ent.vy = 0;
            }

            // --- M√âTODOS DE CONTROL ---

            start() { this.running = true; }

            stop() { this.running = false; }

            // Client.pauseFisica(['zombies'])
            pauseGroups(groups = []) {
                groups.forEach(g => this.pausedGroups.add(g));
            }

            resumeGroups(groups = []) {
                groups.forEach(g => this.pausedGroups.delete(g));
            }

            // --- CHECKERS ---

            // Client.isColisioned(ent)
            isColisioned(ent) {
                // Revisa si est√° dentro de un bloque s√≥lido ahora mismo
                const w = ent.width || 20;
                const h = ent.height || 38;
                return this.map.checkPixel(ent.x + w / 2, ent.y + h / 2);
            }

            setGravity(g, group = null) {
                if (group) {
                    // Si hay grupo, lo guardamos en el mapa espec√≠fico
                    this.groupGravity.set(group, g);
                } else {
                    // Si no hay grupo, cambiamos la global del n√∫cleo
                    this.core.gravity = g;
                }
            }

            // --- BUCLE INTERNO (Se llama desde ClientEngine) ---
            step(dt) {
                if (!this.running) return;

                // Recorremos todas las entidades registradas
                for (const item of this.entities) {
                    // Si el grupo est√° pausado, saltar
                    if (this.pausedGroups.has(item.group)) continue;

                    // 1. Determinar qu√© gravedad usar
                    // Si el grupo tiene una gravedad especial, √∫sala. Si no, usa la global (undefined deja que el core use this.gravity)
                    const specificGravity = this.groupGravity.has(item.group)
                        ? this.groupGravity.get(item.group)
                        : undefined;

                    // 2. Pasar la gravedad al Core
                    this.core.update(item.ref, dt, specificGravity);
                }
            }
        }


        // ==========================================
        // 0. UTILIDADES DE RENDIMIENTO (SPATIAL HASH)
        // ==========================================
        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }
            clear() { this.grid.clear(); }
            _key(x, y) {
                return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)}`;
            }
            insert(obj) {
                const key = this._key(obj.x, obj.y);
                if (!this.grid.has(key)) this.grid.set(key, []);
                this.grid.get(key).push(obj);
            }
            getNearby(obj) {
                const objects = [];
                const cx = Math.floor(obj.x / this.cellSize);
                const cy = Math.floor(obj.y / this.cellSize);
                for (let x = cx - 1; x <= cx + 1; x++) {
                    for (let y = cy - 1; y <= cy + 1; y++) {
                        const key = `${x},${y}`;
                        if (this.grid.has(key)) objects.push(...this.grid.get(key));
                    }
                }
                return objects;
            }
        }

        // ==========================================
        // 1. RENDER ENGINE (GR√ÅFICOS Y CANVAS)
        // ==========================================
        class Render {
            constructor(engine) {
                this.engine = engine; // Referencia al cerebro (para c√°mara y assets)
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.width = 0;
                this.height = 0;
                // ‚òÖ MEMORIA VISUAL
                // Aqu√≠ guardamos d√≥nde estaba el objeto visualmente en el frame anterior
                this.visualCache = new Map();
                // Sistema de Video y Part√≠culas
                this.particles = [];
                this.autoClear = true;
                this.initSystem();
                this.startLoop();
            }

            initSystem() {
                const updateSize = () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.canvas.width = this.width;
                    this.canvas.height = this.height;
                    this.ctx.imageSmoothingEnabled = false;
                    // Actualizar dimensiones en el motor l√≥gico si es necesario
                    this.engine.width = this.width;
                    this.engine.height = this.height;
                };
                window.addEventListener('resize', updateSize);
                updateSize();
            }

            startLoop() {
                const loop = () => {
                    if (this.autoClear) {
                        this.ctx.clearRect(0, 0, this.width, this.height);
                    }
                    this.engine.updateCamera(); // La c√°mara es l√≥gica, pero afecta al render
                    if (window.onRender) window.onRender(); // Hook del usuario
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }

            // ==========================================
            // ‚òÖ EL ALGORITMO DE SUAVIZADO (LERP)
            // ==========================================
            // Calcula una posici√≥n intermedia para que se vea fluido
            getSmoothPos(ent, factor = 0.3) {
                // factor 0.1 = Muy suave (con delay notable)
                // factor 0.3 = Suave y reactivo (Balanceado)
                // factor 1.0 = Instant√°neo (Sin suavizado)

                // 1. Si es la primera vez que lo vemos, lo guardamos tal cual
                if (!this.visualCache.has(ent)) {
                    this.visualCache.set(ent, { x: ent.x, y: ent.y });
                    return { x: ent.x, y: ent.y };
                }

                const vis = this.visualCache.get(ent);

                // 2. Detectar TELETRANSPORTE REAL (Mouse clic, respawn)
                // Si la distancia es enorme (ej: m√°s de 100px), saltamos directo sin suavizar
                const dist = Math.abs(ent.x - vis.x) + Math.abs(ent.y - vis.y);
                if (dist > 150) {
                    vis.x = ent.x;
                    vis.y = ent.y;
                    return vis;
                }

                // 3. INTERPOLACI√ìN (LERP)
                // Movemos el visual un % hacia la posici√≥n real
                vis.x += (ent.x - vis.x) * factor;
                vis.y += (ent.y - vis.y) * factor;

                // 4. SNAP (Evitar micropasos infinitos)
                // Si est√° muy cerca (0.01px), lo forzamos a la posici√≥n final para dejar de calcular
                if (Math.abs(ent.x - vis.x) < 0.01) vis.x = ent.x;
                if (Math.abs(ent.y - vis.y) < 0.01) vis.y = ent.y;

                return vis;
            }

            // --- M√âTODOS DE DIBUJO ---

            // DIBUJAR ENTIDAD SUAVIZADA (Usar este para Jugador/Enemigos)
            drawEntity(ent, color, factor = 0.3) {
                // Obtenemos la posici√≥n "falsa" pero suave
                const pos = this.getSmoothPos(ent, factor); // 0.3 es un buen valor

                const w = ent.width || 20;
                const h = ent.height || 38;

                this.ctx.fillStyle = color || ent.color || 'white';

                // Dibujamos usando la posici√≥n visual (pos), no la f√≠sica (ent)
                this.ctx.fillRect(
                    pos.x - this.engine.camera.x,
                    pos.y - this.engine.camera.y,
                    w, h
                );
            }

            // --- M√âTODOS DE DIBUJO (API P√öBLICA) ---

            drawRect(x, y, w, h, c) {
                this.ctx.fillStyle = c;
                this.ctx.fillRect(
                    x - this.engine.camera.x,
                    y - this.engine.camera.y,
                    w, h
                );
            }

            drawRotatedRect(x, y, w, h, color, angle) {
                const rx = x - this.engine.camera.x;
                const ry = y - this.engine.camera.y;
                // Culling
                if (rx + w < 0 || rx > this.width || ry + h < 0 || ry > this.height) return;

                this.ctx.save();
                this.ctx.translate(rx + w / 2, ry + h / 2);
                this.ctx.rotate(angle);
                this.ctx.fillStyle = color;
                this.ctx.fillRect(-w / 2, -h / 2, w, h);
                this.ctx.restore();
            }

            drawText(text, x, y, color = 'white', size = 16) {
                this.ctx.fillStyle = color;
                this.ctx.font = `bold ${size}px sans-serif`;
                this.ctx.fillText(
                    text,
                    x - this.engine.camera.x,
                    y - this.engine.camera.y
                );
            }

            // --- IM√ÅGENES Y SPRITES ---

            createStaticSprite(name, w, h, drawFn) {
                const offCanvas = document.createElement('canvas');
                offCanvas.width = w; offCanvas.height = h;
                const offCtx = offCanvas.getContext('2d');
                drawFn(offCtx);
                this.engine.assets.images[name] = offCanvas; // Guardamos en assets compartidos
            }

            drawSprite(name, x, y, w, h, angle = 0) {
                const img = this.engine.assets.images[name];
                if (!img) return;

                const rx = x - this.engine.camera.x;
                const ry = y - this.engine.camera.y;
                if (rx + w < 0 || rx > this.width || ry + h < 0 || ry > this.height) return;

                this.ctx.save();
                this.ctx.translate(rx + w / 2, ry + h / 2);
                if (angle !== 0) this.ctx.rotate(angle);
                this.ctx.drawImage(img, -w / 2, -h / 2, w, h);
                this.ctx.restore();
            }

            // --- MAPA ---

            prerenderMap(mapData, totalW, totalH) {
                const mapCanvas = document.createElement('canvas');
                mapCanvas.width = totalW; mapCanvas.height = totalH;
                const mCtx = mapCanvas.getContext('2d');
                for (const b of mapData) {
                    mCtx.fillStyle = b.color || '#444';
                    mCtx.fillRect(b.x, b.y, b.w, b.h);
                }
                this.engine.assets.images['FULL_MAP'] = mapCanvas;
            }

            drawMap() {
                const mapImg = this.engine.assets.images['FULL_MAP'];
                if (!mapImg) return;
                this.ctx.drawImage(
                    mapImg,
                    this.engine.camera.x, this.engine.camera.y, this.width, this.height,
                    0, 0, this.width, this.height
                );
            }

            renderWorld(tileSize = 40) {
                const cam = this.engine.camera;
                const sx = Math.floor(cam.x / tileSize) - 1;
                const sy = Math.floor(cam.y / tileSize) - 1;
                const ex = sx + Math.ceil(this.width / tileSize) + 2;
                const ey = sy + Math.ceil(this.height / tileSize) + 2;

                for (let y = sy; y <= ey; y++) {
                    for (let x = sx; x <= ex; x++) {
                        const instr = this.engine.worldMap.get(`${x},${y}`);
                        if (!instr) continue;

                        const rx = x * tileSize - (cam.x + cam.shake.x);
                        const ry = y * tileSize - (cam.y + cam.shake.y);

                        this.ctx.fillStyle = instr.color;
                        if (instr.shape === 'rect') this.ctx.fillRect(rx, ry, tileSize, tileSize);
                        if (instr.shape === 'circle') {
                            this.ctx.beginPath();
                            this.ctx.arc(rx + tileSize / 2, ry + tileSize / 2, tileSize / 2 - 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
            }

            // --- VIDEO ---

            loadVideo(name, source) {
                if (this.engine.assets.videos[name]) return;
                const vid = document.createElement('video');
                vid.autoplay = true; vid.muted = true; vid.loop = true; vid.controls = false;
                vid.setAttribute('playsinline', ''); vid.crossOrigin = "anonymous";
                const sTag = document.createElement('source');
                sTag.src = source; sTag.type = 'video/mp4';
                vid.appendChild(sTag);

                const forcePlay = () => { if (vid.paused) vid.play(); };
                ['mousedown', 'touchstart', 'keydown'].forEach(e => window.addEventListener(e, forcePlay));

                this.engine.assets.videos[name] = vid;
                vid.load();
            }

            drawVideo(name, x, y, w, h, opacity = 1.0) {
                const vid = this.engine.assets.videos[name];
                if (!vid || vid.readyState < 2) return;
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.drawImage(vid, Math.floor(x - this.engine.camera.x), Math.floor(y - this.engine.camera.y), w, h);
                this.ctx.restore();
            }

            // --- PART√çCULAS ---

            initParticlePool(count) {
                this.particles = Array.from({ length: count }, () => ({
                    active: false, x: 0, y: 0, vx: 0, vy: 0,
                    life: 0, maxLife: 0, size: 0, color: '', gravity: 0
                }));
            }

            spawnParticle(config) {
                const p = this.particles.find(p => !p.active);
                if (!p) return;
                Object.assign(p, {
                    active: true, x: config.x, y: config.y,
                    vx: config.vx || (Math.random() - 0.5) * (config.speed || 5),
                    vy: config.vy || (Math.random() - 0.5) * (config.speed || 5),
                    life: config.life || 1.0, maxLife: config.life || 1.0,
                    size: config.size || 3, color: config.color || '#fff',
                    gravity: config.gravity || 0, restitution: config.restitution || 0.8
                });
            }

            updateParticles() {
                // L√≥gica f√≠sica simple integrada en render para efectos visuales
                for (const p of this.particles) {
                    if (!p.active) continue;
                    p.life -= 0.016;
                    if (p.life <= 0) { p.active = false; continue; }
                    p.vy += p.gravity;
                    p.x += p.vx;
                    p.y += p.vy;
                }
            }

            drawParticles() {
                for (const p of this.particles) {
                    if (!p.active) continue;
                    this.ctx.globalAlpha = p.life / p.maxLife;
                    this.ctx.fillStyle = p.color;
                    this.ctx.fillRect(
                        Math.floor(p.x - this.engine.camera.x),
                        Math.floor(p.y - this.engine.camera.y),
                        p.size, p.size
                    );
                }
                this.ctx.globalAlpha = 1.0;
            }
        }

        // ==========================================
        // 2. CLIENT ENGINE (L√ìGICA, RED, AUDIO)
        // ==========================================
        class ClientEngine {
            constructor() {
                this.socket = null;
                this.myId = null;
                this.myPlayer = null;
                this.width = 0; this.height = 0; // Se actualizan desde Render

                this.assets = { images: {}, sounds: {}, videos: {} };
                this.inputState = { keys: {}, mouse: { x: 0, y: 0, down: false } };
                this.lastInputState = { keys: {}, mouse: { down: false } };
                this.actions = {};
                this.frameKeys = []; // Buffer de teclas RAW


                // Inicializamos la API
                this.physics = new PhysicsAPI(this);

                // Alias directos para usar en el script como pediste
                // (Esto permite usar Client.setBlock en lugar de Client.physics.setBlock)
                this.setBlock = (x, y, w, h, solid) => this.physics.setBlock(x, y, w, h, solid);
                this.startFisica = () => this.physics.start();
                this.stopFisica = () => this.physics.stop();
                this.pauseFisica = (gr) => this.physics.pauseGroups(gr);
                this.resumeFisica = (gr) => this.physics.resumeGroups(gr);
                this.setEntidad = (ent, x, y) => this.physics.setTransform(ent, x, y);
                this.addEntidades = (list, group) => this.physics.addEntities(list, group);
                this.isColisioned = (ent) => this.physics.isColisioned(ent);
                this.initMapFisica = (blocks, auto) => this.physics.initMap(blocks, auto);
                this.gravity = (g, gr) => this.physics.setGravity(g, gr);
                
                // AUDIO
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                this.audioBuffers = {};

                // RED
                this.netRate = 30;
                this.netBuffer = {};
                this.interpDelay = 100;
                this.netInterval = 1000 / this.netRate;
                this.lastNetTime = 0;
                this.inputQueue = { move: null, actions: [] };

                // ESTADO MUNDO
                this.worldMap = new Map();
                this.camera = { x: 0, y: 0, targetX: 0, targetY: 0, lerp: 0.1, shake: { x: 0, y: 0, intensity: 0 } };

                this.mouseScreen = { x: 0, y: 0 };
                this.eventListeners = [];

                // INICIALIZACI√ìN
                this.render = new Render(this); // Vinculamos Render
                this.autoClear = (auto) => { this.render.autoClear = auto; };
                this.drawEntity = (ent, color, factor) => { this.render.drawEntity(ent, color, factor); };
                this.initInputSystem();
                this.startInputLoop();
            }

            // --- PROXIES AL RENDER ---
            get ctx() { return this.render.ctx; } // Retrocompatibilidad
            get canvas() { return this.render.canvas; }

            // Exponemos m√©todos de render para que los scripts de usuario los usen via 'Client'
            drawRect(...args) { this.render.drawRect(...args); }
            drawText(...args) { this.render.drawText(...args); }            
            drawRotatedRect(...args) { this.render.drawRotatedRect(...args); }
            drawVideo(...args) { this.render.drawVideo(...args); }
            renderWorld(...args) { this.render.renderWorld(...args); }
            spawnParticle(...args) { this.render.spawnParticle(...args); }
            drawParticles() { this.render.drawParticles(); }
            updateParticles() { this.render.updateParticles(); }
            loadVideo(...args) { this.render.loadVideo(...args); }

            // --- SISTEMA DE INPUT ---
            initInputSystem() {
                window.addEventListener('keydown', e => {
                    this.inputState.keys[e.code] = true;
                    if (!e.repeat) this.frameKeys.push(e.code);
                });
                window.addEventListener('keyup', e => this.inputState.keys[e.code] = false);

                window.addEventListener('mousemove', e => {
                    this.mouseScreen.x = e.clientX;
                    this.mouseScreen.y = e.clientY;
                    this.updateMouseWorld();
                });

                window.addEventListener('mousedown', () => this.inputState.mouse.down = true);
                window.addEventListener('mouseup', () => this.inputState.mouse.down = false);
                window.addEventListener('contextmenu', e => e.preventDefault());

                const handleTouch = (e) => {
                    if (e.touches.length > 0) {
                        const r = this.render.canvas.getBoundingClientRect();
                        const t = e.touches[0];
                        this.mouseScreen.x = t.clientX - r.left;
                        this.mouseScreen.y = t.clientY - r.top;
                        this.updateMouseWorld();
                    }
                };
                window.addEventListener('touchstart', e => { this.inputState.mouse.down = true; handleTouch(e); }, { passive: false });
                window.addEventListener('touchmove', e => { if (e.target === this.render.canvas) e.preventDefault(); handleTouch(e); }, { passive: false });
                window.addEventListener('touchend', e => { if (e.touches.length === 0) this.inputState.mouse.down = false; });
            }

            updateMouseWorld() {
                this.inputState.mouse.x = this.mouseScreen.x + this.camera.x;
                this.inputState.mouse.y = this.mouseScreen.y + this.camera.y;
            }

            startInputLoop() {
                setInterval(() => {
                    if (window.onInputLoop) {
                        try { window.onInputLoop(); } catch (e) { console.error("Input Error:", e); }
                    }
                    // 2. F√çSICAS (60Hz)
                    // Aqu√≠ es donde ocurre la magia
                    this.physics.step(0.016);
                    this.updateInputSnapshots();
                }, 16);
            }

            updateInputSnapshots() {
                this.lastInputState.keys = { ...this.inputState.keys };
                this.lastInputState.mouse.down = this.inputState.mouse.down;
                this.lastInputState.mouse.rightDown = this.inputState.mouse.rightDown;
                this.frameKeys = [];
            }

            // --- UTILS INPUT ---
            bind(name, key) { this.actions[name] = key; }
            isPress(id) {
                const target = this.actions[id] || id;

                // Mapeos especiales de Mouse
                if (target === 'LeftClick') return this.inputState.mouse.down;
                if (target === 'RightClick') return !!this.inputState.mouse.rightDown;

                // Mapeos especiales de Teclado
                if (target === 'Shift') return !!this.inputState.keys['ShiftLeft'] || !!this.inputState.keys['ShiftRight'];

                // Verificaci√≥n normal
                return !!this.inputState.keys[target];
            }
            isKeyDown(code) { return !!this.inputState.keys[code]; }
            isJustPressed(id) {
                const target = this.actions[id] || id;

                if (target === 'LeftClick') return this.inputState.mouse.down && !this.lastInputState.mouse.down;
                if (target === 'RightClick') return !!this.inputState.mouse.rightDown && !this.lastInputState.mouse.rightDown;

                return !!this.inputState.keys[target] && !this.lastInputState.keys[target];
            }
            get worldMouse() { return this.inputState.mouse; }
            worldToGrid(wx, wy, tileSize = 40) { return { tx: Math.floor(wx / tileSize), ty: Math.floor(wy / tileSize) }; }

            // --- C√ÅMARA ---
            setCamera(pos, lerp = null, mapUpdate = null) {
                if (pos) { this.camera.targetX = pos.x - this.width / 2; this.camera.targetY = pos.y - this.height / 2; }
                if (lerp !== null) this.camera.lerp = lerp;
                if (mapUpdate && mapUpdate.length > 0) {
                    for (let i = 0; i < mapUpdate.length; i += 3) {
                        const gx = mapUpdate[i];
                        const gy = mapUpdate[i + 1];
                        const data = mapUpdate[i + 2];

                        // VISUAL (Para el Render)
                        this.worldMap.set(`${gx},${gy}`, data);

                        // L√ìGICO (Para la F√≠sica: 0 o 1)
                        // Si data existe es 1, si no (o si es null) se borra
                        this.colGrid.set(gx, gy, 1);
                    }
                }
            }
            // M√©todo para cuando destruyes/construyes bloques localmente (Predicci√≥n)
            updateBlock(gx, gy, type) {
                if (type === 'build') {
                    this.colGrid.set(gx, gy, 1);
                    // Tambi√©n actualizar worldMap visual...
                } else {
                    this.colGrid.set(gx, gy, 0); // Pasamos a 0 (Aire)
                    // Borrar de worldMap visual...
                }
            }

            updateCamera() {
                this.camera.x += (this.camera.targetX - this.camera.x) * this.camera.lerp;
                this.camera.y += (this.camera.targetY - this.camera.y) * this.camera.lerp;
                // Shake logic
                if (this.camera.shake.intensity > 0.1) {
                    this.camera.shake.x = (Math.random() - 0.5) * this.camera.shake.intensity;
                    this.camera.shake.y = (Math.random() - 0.5) * this.camera.shake.intensity;
                    this.camera.shake.intensity *= 0.9;
                } else { this.camera.shake.x = 0; this.camera.shake.y = 0; }
            }
            get cx() { return Math.round(this.camera.x + this.camera.shake.x); }
            get cy() { return Math.round(this.camera.y + this.camera.shake.y); }

            // --- RED ---
            emit(type, payload = {}) {
                if (!this.socket) return;
                if (!payload.id) payload.id = this.myId;
                if (type === 'action_move') this.inputQueue.move = payload;
                else this.inputQueue.actions.push({ type, payload });

                const now = performance.now();
                if (now - this.lastNetTime > this.netInterval) {
                    this._flushNetwork();
                    this.lastNetTime = now;
                }
            }

            _flushNetwork() {
                if (!this.inputQueue.move && this.inputQueue.actions.length === 0) return;
                const packet = {};
                if (this.inputQueue.move) { packet.m = this.inputQueue.move; this.inputQueue.move = null; }
                if (this.inputQueue.actions.length > 0) { packet.a = this.inputQueue.actions; this.inputQueue.actions = []; }
                this.socket.emit('client_tick', packet);
            }

            on(event, callback) {
                if (this.socket) this.socket.on(event, callback);
                else this.eventListeners.push({ event, callback });
            }

            // --- AUDIO ---
            async loadSound(name, src) {
                try {
                    const res = await fetch(src);
                    this.audioBuffers[name] = await this.audioCtx.decodeAudioData(await res.arrayBuffer());
                } catch (e) { console.error("Audio error", e); }
            }

            playSound(name, vol = 1.0) {
                const buf = this.audioBuffers[name];
                if (!buf) return;
                if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
                const src = this.audioCtx.createBufferSource();
                const gain = this.audioCtx.createGain();
                src.buffer = buf; gain.gain.value = vol;
                src.connect(gain); gain.connect(this.audioCtx.destination);
                src.start(0);
            }
        }

        const Client = new ClientEngine();    
    </script>

    <script id="initial-render" th:utext="'{ ' + ${clientRenderScript} + ' }'"></script>
    <script id="initial-input" th:utext="'{ ' + ${clientInputScript} + ' }'"></script>

    <script>
        // ==========================================
        // BOOTSTRAPPER (INICIO DEL JUEGO)
        // ==========================================
        const body = document.body;
        const ROOM_ID = body.dataset.roomId;
        // Si no hay usuario, generamos uno temporal
        const USER_NAME = body.dataset.userName || 'Anon_' + Math.floor(Math.random() * 1000);
        const API_BASE = body.dataset.apiBase;

        // Inyector de c√≥digo din√°mico
        function injectScripts(data) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('status').innerText = "";
            if (data.structure) document.getElementById('ui-layer').innerHTML = data.structure;

            // Remover scripts viejos si existieran
            document.querySelectorAll('.dynamic-code').forEach(el => el.remove());

            // Inyectar nuevos
            [data.renderScript, data.inputScript].forEach(code => {
                if (!code) return;
                const s = document.createElement('script');
                s.className = 'dynamic-code';
                s.textContent = `{ ${code} }`;
                document.body.appendChild(s);
            });
            console.log("üõ†Ô∏è C√≥digo inyectado.");
        }


        function initGame() {
            const socket = io(API_BASE, { query: { roomId: ROOM_ID } });
            Client.socket = socket;

            socket.on('connect', () => {
                console.log("‚úÖ Conectado. Mi ID:", USER_NAME);
                Client.myId = USER_NAME;
                socket.emit('join_room', ROOM_ID, USER_NAME);
                document.getElementById('loader').style.display = 'none';
                document.getElementById('status').innerText = "";
            });

            // Recarga de c√≥digo en caliente (Hot Reload)
            socket.on('design_update', (data) => {
                Client.netBuffer = {}; // Limpiar interpolaci√≥n vieja
                injectScripts(data);
            });

            // Manejo de desconexi√≥n
            socket.on('disconnect', () => {
                console.warn("‚ö†Ô∏è Desconectado del servidor.");
                // Opcional: Mostrar loader de nuevo o un aviso
                document.getElementById('loader').style.display = 'flex';
                document.getElementById('status').innerText = "Reconectando...";

            });

            // Cargar scripts iniciales (si vienen del HTML server-side)
            const initialData = {
                structure: null, // Ya est√° en el HTML
                renderScript: document.getElementById('initial-render').textContent,
                inputScript: document.getElementById('initial-input').textContent
            };
            injectScripts(initialData);
        }

        window.onload = initGame;
    </script>

</body>

</html>